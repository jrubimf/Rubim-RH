--RubimRH.createMacro()
--RubimRH.editMacro()

local HL = HeroLib;
local Cache = HeroCache;
local Unit = HL.Unit;
local Player = Unit.Player;
local Pet = Unit.Pet;
local Target = Unit.Target;
local Arena = Unit.Arena;
local Spell = HL.Spell;
local Item = HL.Item;
local debug = RubimRH.DebugPrint

local function updateArena()
    local ArenaUnits = Unit["Arena"]
    for i = 1, 3 do
        local ArenaUnit = ArenaUnits["arena" .. tostring(i)]
        if UnitExists("arena" .. i) then
            if ArenaUnit then
                ArenaUnit:Cache()
            end
        end
    end
end

local RubimRHPvP = LibStub("AceAddon-3.0"):NewAddon("RubimRHPvP", "AceEvent-3.0", "AceConsole-3.0")
_G["RubimRH"] = RubimRH
_G["RubimRHPvP"] = RubimRHPvP

RubimPvP = true
RubimRHPvP.active = true

local defaults = {
    profile = {
        mainOption = {
            interruptsFrom = 40,
            interruptsTo = 85,
            channelingFrom = 15,
            channelingTo = 85,
        },
    }
}
function RubimRHPvP:OnInitialize()
    self.db = LibStub("AceDB-3.0"):New("RubimRHPvPDB", defaults, true)
    self.db.RegisterCallback(self, "OnProfileChanged", "OnProfileChanged")
    self.db.RegisterCallback(self, "OnProfileCopied", "OnProfileChanged")
    self.db.RegisterCallback(self, "OnProfileReset", "OnProfileReset")
    self.db.RegisterCallback(self, "OnNewProfile", "OnNewProfile")
    self:SetupOptions()
end

local interruptRandom = 0
local interruptChannel = 0

local options, configOptions = nil, {}
--[[ This options table is used in the GUI config. ]]--
local function getOptions()
    return options
end

function RubimRHPvP:SetupOptions()
    self.optionsFrames = {}
    LibStub("AceConfigRegistry-3.0"):RegisterOptionsTable("RubimRHPvP", getOptions)
    configOptions["Profiles"] = LibStub("AceDBOptions-3.0"):GetOptionsTable(self.db)
    self.optionsFrames["Profiles"] = LibStub("AceConfigDialog-3.0"):AddToBlizOptions("RubimRHPvP", "Profiles", "RubimRHPvP", "Profiles")
end

function RubimRHPvP:OnProfileChanged(event, db)
    self.db.profile = db.profile
end

function RubimRHPvP:OnProfileReset(event, db)
    for k, v in pairs(defaults) do
        db.profile[k] = v
    end
    self.db.profile = db.profile
end

function RubimRHPvP:OnNewProfile(event, db)
    for k, v in pairs(defaults) do
        db.profile[k] = v
    end
end
local AceGUI = LibStub("AceGUI-3.0")
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Rubim.
--- DateTime: 14/06/2018 10:19
---


RubimRH.CleaveSpell = {}

local pvpSpells = {
    211714, -- Thal'kiel's Consumption
    157695, -- Demonbolt**
    32375, --Mass Dispel (only if our team mate has bubble/iceblock active)
    48181, -- Haunt
    202771, -- Full Moon*
    199786, -- Glacial Spike
    116858, -- Chaos Bolt
    105174, -- Hand of Gul'dan
    228260, -- Void Eruption
    34914, -- Vampiric Touch
    124465, -- Vampiric Touch
    30108, -- Unstable Affliction
    214634, -- Ebonbolt
    205495, -- Stormkeeper
}
local pvpDMG = {
    116, --  Frostbolt
    2948, --  Scorch
    51505, --  Lava Burst
    403, --  Lightnin Bolt
    1120, --  Drain Soul
    48181, --  Haunt
    30451, --  Arcane Blast
    113092, --  Frost Bomb
    8092, --  Mind Blast
    11366, --  Pyroblast
    126201, --  Frost Bolt
    15407, --  Mind Flay
    44614, --  Frostfire Bolt
    133, --  Fireball
    103103, --  Malefic Grasp
    117014, --  Elemental Blast
    118297     --  Immolate
}
local pvpHEALING = {
    2060, --Heal
    5185, --  Healing Touch
    8936, --  Regrowth
    50464, --  Nourish
    19750, --  Flash of Light
    82326, --  Divine Light
    2061, --  Flash Heal
    64901, --  Hymn of Hope
    12051, --  Evocation
    64843, --  Divine Hymn
    115175, --  Soothing Mist
    8936, --  Regrowth
    2061, --  Flash Heal
    32546, --  binding Heal
    2060, --  Greater Heal
    2006, --  Resurrection
    5185, --  Healing Touch
    596, --  Prayer of Healing
    19750, --  Flash of Light
    635, --  Holy Light
    7328, --  Redemption
    2008, --  Ancestral Spirit
    50769, --  Revive
    82327, --  Holy Radiance
    82326, --  Divine Light
    740, --  Tranquillity
    116694, --  Surging Mist
    124682, --  Enveloping Mist
    64901, --  Hymn of Hope
    64843, --  Divine Hymn
    115151, --  Renewing Mist
    115310, --  Revival
    152118, --  Clarity of Will
    85673, --  Word of Glory
    152116, --  Saving Grace
    186263  --  Shadow Mend
}
local pvpHEX = {
    5782, --  Fear
    33786, --  Cyclone
    28272, --  Pig Poly (if we have a resto Druid team mate check if out of form)
    118, --  Sheep Poly (same as above ^^)
    61305, --  Cat Poly (^^)
    61721, --  Rabbit Poly (^^)
    61780, --  Turkey Poly (^^)
    28271, --  Turtle Poly (^^)
    51514, --  Hex (Only kick if we do not have a feral Druid in our team)
    20066, --  Repentance
    82012, --  Repentance
    605, --  Dominate Mind
}
local pvpBreakableCC = {
    118, -- Sheep
    28271, -- Turtle
    61780, -- Turkey
    61721, -- Rabbit
    61305, -- Black Cat
    28272, -- Pig
    6770, -- Sap
    20066, -- Repentance
    51514, -- Hex
    211004, -- Hex
    210873, -- Hex
    211015, -- Hex
    211010, -- Hex
    5782, -- Fear
    3355, -- Freezing Trap
    209790, -- Freezing Arrow (Talent)
    6358, -- Seduction
    2094, -- Blind
    19386, -- Wyverm Sting
    82691, -- Ring of Frost
    115078, -- Paralysis
    115268, -- Mesmerize
    5484, -- Howl of Terror
    5246, -- Intimidating Shout
    6789, -- Mortal Coil
    8122, -- Psychic Scream
    99, -- Incapacitating Roar
    1776, -- Gouge
    31661, -- Dragon's Breath
    105421, -- Blinding Light
    186387, -- Bursting Shot
    202274, -- Incendiary Brew
    207167, -- Blinding Sheet
    213691, -- Scatter Shot (Honor)
    605, -- Mind Control
    217832, -- Imprison
    339, -- Entagle Roots
    34787, --Frozen Circles
}
local pvpDisarm = {
    207777,
    236077,
    236236,
    209749,
    233759
}
local pvpReflect = {
    161372, -- Poly
    190319, -- Combustion
    161372, -- Polymorph
    203286, -- Greater Pyroblast
    199786, --  Glacial Spike
    257537, -- Ebonbolt
    161372, -- Polymorph
    210714, -- Icefury
    191634, -- Stormkeeper
    116858, -- Chaos Bolt
}
local pvpBurst = {
    51271, -- Pillar of Frost
    47568, -- Empower Rune Weapon
    152279, -- Breath of Sindragosa

    63560, -- Dark Transformation
    49206, -- Summon Gargoyle
    207289, -- Unholy Frenzy

    106951, -- Berserk
    5217, -- Tiger's Fury
    102543, -- Incarnation: King of the Jungle

    202770, -- Fury of Elune
    194223, -- Celestial Alignment
    205636, -- Force of Nature
    102560, -- Incarnation: Chosen of Elune

    193526, -- Trueshot

    266779, -- Coordinated Assault
    186289, -- Aspect of the Eagle
    19574, -- Bestial Wrath
    193530, -- Aspect of the Wild
    201430, -- Stampede
    131894, -- A Murder of Crows
    194407, -- Spitting Cobra
    264667, -- Primal Rage

    152173, -- Serenity
    115080, -- Touhc of Death
    137639, -- Storm, Earth, and Fire
    123904, -- Invoke Xuen, the White Tiger

    31884, -- Avenging Wrath
    231895, -- Crusade

    79140, -- Vendetta

    121471, -- Shadow of Blades
    185313, -- Shadow Dance
    212283, -- Symbols of Death

    13750, -- Adrenaline Rush
    13877, -- Blade Furry
    57934, -- Tricks of the Trade
    51690, -- Killing Spree

    191427, -- Metamorphosis
    162264, -- Metamorphosis
    206491, -- Nemesis

    12042, -- Arcane Power
    205025, -- Presence of Mind

    190319, -- Combustion
    161372, -- Polymorph
    203286, -- Greater Pyro Blast

    12472, -- Icy Veins
    199786, -- Glacial Spike
    257537, -- Ebonbolt

    34433, -- Shadowfiend
    228260, -- Void Eruption

    210714, -- Icefury
    191634, -- Stormkeeper
    114050, -- Ascendance

    51533, -- Feral Spirit
    114052, -- Ascendance

    205180, -- Summon Darkglare
    264106, -- Dethbolt
    30108, -- Unstable Affliction
    113860, -- Dark Soul: Misery

    1122, -- Summon Infernal

    265187, -- Summon Demonic Tyrant
}
local pvpImmunity = {
    196555, -- Netherwak
    198111, -- Temporal Shield
    45438, -- Iceblock
    642, -- Divine Shield
    184662, -- Shield of Vengeance
    47585, -- Dispersion
    212295, --Netherward
    33786, --  Cyclone
    186265, -- Aspect of Turtle
}
local pvpStunImmunity = {
    48792, -- Icebound Fortitude
    53271, -- Master's Call
    198144, --Iceform
}
local pvpDefensiveAll = {
    48792, -- Icebound Fortitude
    61336, -- Survival Instics
    207319, --Corpse Shield
    53480, --Roar of Sacrifice
    122278, --Dampem Harm
    115203, --Fortifying Brew
    31850, --Ardent Defender
    33206, --Pain Suppresion
    108271, --Astral Shift
    104773, --Unending REsolve
    871, --Shield Wall


}
local pvpImmuneMagic = {
    48707, -- AMS
    122783, -- Diffuse Magic
    31224, -- Cloak of Shadows
}
local pvpImmunePhys = {
    212800, -- Blur
    1022, -- Blessing of Protection
    5277, -- Evasion
    199754, -- Riposte
    210918, -- Ethereal Form
    118038, -- Die by Sword
    236696, -- Thorns
}

local PvPMelee = {
    250,
    251,
    252,
    577,
    581,
    103,
    104,
    255,
    268,
    269,
    70,
    259,
    260,
    261,
    263,
    71,
    72,
    73,
}
local PvPRangedClass = {
    3,
    5,
    7,
    8,
    9,
    11
}
local PvPDesarmableClass = {
    1,
    2,
    3,
    4,
    6,
    12,
}

function Unit:IsDisarmed()
    if not self:Exists() then
        return false
    end

    for p = 1, #pvpDisarm do
        if self:DebuffPvP(Spell(pvpDisarm[p])) then
            return true
        end
    end
    return false
end
function Unit:IsRanged()
    local target = self.UnitID
    if target == nil then
        return false
    end
    id = select(3, UnitClass(target))
    for i = 1, #PvPRangedClass do
        if id == PvPRangedClass[i] then
            return true
        end
    end
    return false
end
function Unit:IsDisarmable()
    local target = self.UnitID
    if target == nil then
        return false
    end
    id = select(3, UnitClass(target))
    for i = 1, #PvPDesarmableClass do
        if id == PvPDesarmableClass[i] then
            return true
        end
    end
    return false
end
function Unit:IsBursting()
    if not self:Exists() then
        return false
    end

    for p = 1, #pvpBurst do
        if self:BuffPvP(Spell(pvpBurst[p])) then
            return true
        end
    end
    return false
end
function Unit:IsCC()
    if not self:Exists() then
        return false
    end

    for p = 1, #pvpBreakableCC do
        if self:BuffPvP(Spell(pvpBreakableCC[p])) then
            return true
        end
        if self:DebuffPvP(Spell(pvpBreakableCC[p])) then
            return true
        end
    end
    return false
end
function Unit:AreaCC(range)
    if not self:Exists() then
        return false
    end

    local range = range or 10
    HL.GetEnemies(range, true);
    for _, CycleUnit in pairs(Cache.Enemies[range]) do
        for p = 1, #pvpBreakableCC do
            if CycleUnit:DebuffPvP(Spell(pvpBreakableCC[p])) then
                return true
            end
        end
    end
    return false
end
function Unit:IsImmuneMagic()
    if not self:Exists() then
        return false
    end

    for p = 1, #pvpImmuneMagic do
        if self:Buff(Spell(pvpImmuneMagic[p])) then
            return true
        end

        if self:DebuffPvP(Spell(pvpImmuneMagic[p])) then
            return true
        end
    end
    return false
end
function Unit:IsImmunePhys()
    if not self:Exists() then
        return false
    end

    for p = 1, #pvpImmunePhys do
        if self:Buff(Spell(pvpImmunePhys[p])) then
            return true
        end

        if self:DebuffPvP(Spell(pvpImmunePhys[p])) then
            return true
        end
    end
    return false
end
function Unit:IsImmune()
    if not self:Exists() then
        return false
    end
    for p = 1, #pvpImmunity do


        if self:BuffPvP(Spell(pvpImmunity[p])) then
            return true
        end

        if self:DebuffPvP(Spell(pvpImmunity[p])) then
            return true
        end
    end
    return false
end
function Unit:ShouldReflect()
    if not self:Exists() then
        return false
    end
    for p = 1, #pvpReflect do
        if self:IsCasting(Spell(pvpReflect[p])) then
            return true
        end
    end

    return false
end
function Unit:CastingCC()
    if not self:Exists() then
        return false
    end
    for p = 1, #pvpBreakableCC do
        if self:IsCasting(Spell(pvpBreakableCC[p])) then
            return true
        end
    end

    for p = 1, #pvpHEX do
        if self:IsCasting(Spell(pvpHEX[p])) then
            return true
        end
    end
    return false
end
function Unit:CastingHealing()
    if not self:Exists() then
        return false
    end
    for p = 1, #pvpHEALING do
        if self:IsCasting(Spell(pvpHEALING[p])) then
            return true
        end
    end
    return false
end

function RubimRH.isMeleeClass(tar)
    local target = tar.UnitID
    if target == nil then
        return false
    end
    local id = GetInspectSpecialization(tar)

    for i = 1, #PvPMelee do
        if id == PvPMelee[i] then
            return true
        end
    end
    return false
end

local function isRanged(tar)
    local target = tar.UnitID
    if target == nil then
        return false
    end
    id = select(3, UnitClass(target))
    for i = 1, #PvPRangedClass do
        if id == PvPRangedClass[i] then
            return true
        end
    end
    return false
end

function RubimRH.PvPBursting(tar)
    local target = tar.UnitID
    if target == nil then
        return false
    end
    if target == "target" and not UnitExists("target") then
        return false
    end

    --    if Player:DebuffPvP(Spell(122470)) then
    --        return true
    --end

    for p = 1, #pvpBurst do
        --if select( 11, UnitDebuff("target", i)) == pvpCC[i] then
        if target:BuffPvP(Spell(pvpBurst[p])) then
            return true
        end
    end
    return false
end
function RubimRH.PvPSpells(tar)
    if tar == nil then
        return false
    end

    local importantCast = false
    local target = tar
    local castName, _, _, _, castStartTime, castEndTime, _, _, notInterruptable, spellID = UnitCastingInfo(enemyHealer[1].Unit)
    local channel = false

    if castName == nil then
        local castName, nameSubtext, text, texture, castStartTime, castEndTime, isTradeSkill, notInterruptible = UnitChannelInfo(enemyHealer[1].Unit)
        local channel = true
    end

    if spellID == nil or notInterruptable == true then
        return false
    end

    for p = 1, #pvpHEX do
        --if select( 11, UnitDebuff("target", i)) == pvpCC[i] then
        if target:IsCasting(Spell(pvpHEX[p])) then
            importantCast = true
        end
    end

    if importantCast == false then
        return false
    end

    local timeSinceStart = (GetTime() * 1000 - castStartTime) / 1000
    local timeLeft = ((GetTime() * 1000 - castEndTime) * -1) / 1000
    local castTime = castEndTime - castStartTime
    local currentPercent = timeSinceStart / castTime * 100000
    if channel == true and currentPercent >= interruptChannel then
        return true
    end

    if currentPercent >= interruptRandom then
        return true
    end
    return false
end
function RubimRH.InterruptHex(tar)
    if tar == nil then
        return false
    end

    local importantCast = false
    local target = tar
    local castName, _, _, _, castStartTime, castEndTime, _, _, notInterruptable, spellID = UnitCastingInfo(tar.UnitID)
    local channel = false

    if castName == nil then
        local castName, nameSubtext, text, texture, castStartTime, castEndTime, isTradeSkill, notInterruptible = UnitChannelInfo(tar.UnitID)
        local channel = true
    end

    if spellID == nil or notInterruptable == true then
        return false
    end

    for p = 1, #pvpHEALING do
        --if select( 11, UnitDebuff("target", i)) == pvpCC[i] then
        if target:IsCasting(Spell(pvpHEALING[p])) then
            importantCast = true
        end
    end

    if importantCast == false then
        return false
    end

    local timeSinceStart = (GetTime() * 1000 - castStartTime) / 1000
    local timeLeft = ((GetTime() * 1000 - castEndTime) * -1) / 1000
    local castTime = castEndTime - castStartTime
    local currentPercent = timeSinceStart / castTime * 100000

    if channel == true and currentPercent >= interruptChannel then
        return true
    end

    if currentPercent >= interruptRandom then
        return true
    end

    return false
end
function Unit:IsInterruptibleCC()
    if not self:IsInterruptible() then
        return false
    end

    local importantCast = false
    for p = 1, #pvpHEX do
        --if select( 11, UnitDebuff("target", i)) == pvpCC[i] then
        if self:IsCasting(Spell(pvpHEX[p])) then
            importantCast = true
            break
        end
    end

    if importantCast then
        return true
        --end
    end
end
function Unit:IsInterruptibleHeal()
    if not self:IsInterruptible() then
        return false
    end

    local importantCast = false
    for p = 1, #pvpHEALING do
        --if select( 11, UnitDebuff("target", i)) == pvpCC[i] then
        if self:IsCasting(Spell(pvpHEALING[p])) then
            importantCast = true
            break
        end
    end

    if importantCast then
        return true
        --end
    end
end

function findHealer()
    for i = 1, 3 do
        local enemyHealer = "None"
        if GetSpecializationRoleByID(GetArenaOpponentSpec(i)) == "HEALER" then
            print("arena" .. i)
            break
        end
    end
end

local arenaSTART = CreateFrame("Frame")
arenaSTART:RegisterEvent("ARENA_PREP_OPPONENT_SPECIALIZATIONS")
arenaSTART:RegisterEvent("ARENA_OPPONENT_UPDATE")

arenaSTART:SetScript("OnEvent", function(self, event, ...)
    updateArena()
end)

local interruptSpell = 0
RubimRH.InterruptingNext = false
local interruptTime = 0
function RubimRH.InterruptNextHealToggle()
    if RubimRH.InterruptingNext == true then
        print("Auto-Heal Interrupt: OFF")
        RubimRH.InterruptingNext = false
        InfoText:SetText(nil)
    else
        interruptTime = GetTime()
        print("Auto-Heal Interrupt: ON")
        RubimRH.InterruptingNext = true
        InfoText:SetText("Interrupting")
    end
end
function RubimRH.InterruptNextHealCheck()
    if GetTime() - timeElapsed >= 6 and RubimRH.InterruptingNext == true then
        print("Auto-Heal Interrupt: OFF")
        RubimRH.InterruptingNext = false
    end
    return RubimRH.InterruptingNext
end

local refreshRandom = CreateFrame("Frame");
refreshRandom:SetScript("OnUpdate", function(self, sinceLastUpdate)
    refreshRandom:onUpdate(sinceLastUpdate);
end)

function refreshRandom:onUpdate(sinceLastUpdate)
    self.sinceLastUpdate = (self.sinceLastUpdate or 0) + sinceLastUpdate;
    if (self.sinceLastUpdate >= 1) then

        if RubimRH.InterruptingNext == true and GetTime() - interruptTime >= 6 then
            print("Auto-Heal Interrupt: OFF")
            InfoText:SetText(nil)
            RubimRH.InterruptingNext = false
        end

        interruptChannel = math.random(RubimRHPvP.db.profile.mainOption.channelingFrom, RubimRHPvP.db.profile.mainOption.channelingTo)
        interruptRandom = math.random(RubimRHPvP.db.profile.mainOption.interruptsFrom, RubimRHPvP.db.profile.mainOption.interruptsTo)
        self.sinceLastUpdate = 0
    end
end

local PvPSpellSucced = CreateFrame("Frame")
PvPSpellSucced:RegisterEvent("UNIT_SPELLCAST_SUCCEEDED");

PvPSpellSucced:SetScript("OnEvent", function(self, event, ...)
    if event == "UNIT_SPELLCAST_SUCCEEDED" then
        local unit = select(1, ...)
        local spellID = select(5, ...)
        if spellID == RubimRH.Interrupt or spellID == RubimRH.Spell then
            RubimRH.InterruptingNext = false
        end
    end
end)

function RubimRH.PvPConfig()
    local pvpGUI = AceGUI:Create("Frame")
    pvpGUI:SetTitle("PvP Config")
    pvpGUI:SetStatusText("Rubim")
    pvpGUI:SetCallback("OnClose", function(widget)
        AceGUI:Release(widget)
    end)

    pvpGUI:SetAutoAdjustHeight(false)
    pvpGUI:SetLayout("Flow")
    pvpGUI:SetWidth(300)
    pvpGUI:SetHeight(600)

    local interruptText = AceGUI:Create("InlineGroup")
    interruptText:SetTitle("Interrupt (" .. interruptRandom .. ")")
    pvpGUI:AddChild(interruptText)

    local fromInterrupt = AceGUI:Create("Slider")
    fromInterrupt:SetLabel("From:")
    --fromInterrupt:SetWidth(150)
    fromInterrupt:SetValue(RubimRHPvP.db.profile.mainOption.interruptsFrom)
    fromInterrupt:SetFullWidth(true)
    fromInterrupt:SetCallback("OnValueChanged", function(widget, event, value)
        RubimRHPvP.db.profile.mainOption.interruptsFrom = value
    end)
    fromInterrupt:SetSliderValues(5, 95, 5)
    interruptText:AddChild(fromInterrupt)

    local toInterrupt = AceGUI:Create("Slider")
    toInterrupt:SetLabel("To:")
    toInterrupt:SetWidth(150)
    toInterrupt:SetFullWidth(true)
    toInterrupt:SetValue(RubimRHPvP.db.profile.mainOption.interruptsTo)
    toInterrupt:SetCallback("OnValueChanged", function(widget, event, value)
        RubimRHPvP.db.profile.mainOption.interruptsTo = value
    end)
    toInterrupt:SetSliderValues(5, 95, 5)
    interruptText:AddChild(toInterrupt)

    local channellingText = AceGUI:Create("InlineGroup")
    channellingText:SetTitle("Channeling Interrupt (" .. interruptChannel .. ")")
    pvpGUI:AddChild(channellingText)

    local fromChanneling = AceGUI:Create("Slider")
    fromChanneling:SetLabel("From:")
    fromChanneling:SetFullWidth(true)
    fromChanneling:SetValue(RubimRHPvP.db.profile.mainOption.channelingFrom)
    fromChanneling:SetCallback("OnValueChanged", function(widget, event, value)
        RubimRHPvP.db.profile.mainOption.channelingFrom = value
    end)
    fromChanneling:SetSliderValues(5, 95, 5)
    channellingText:AddChild(fromChanneling)

    local toChannelling = AceGUI:Create("Slider")
    toChannelling:SetLabel("To:")
    toChannelling:SetFullWidth(true)
    toChannelling:SetValue(RubimRHPvP.db.profile.mainOption.channelingTo)
    toChannelling:SetCallback("OnValueChanged", function(widget, event, value)
        RubimRHPvP.db.profile.mainOption.channelingTo = value
    end)
    toChannelling:SetSliderValues(5, 95, 5)
    channellingText:AddChild(toChannelling)

    local PvPHotkeys = AceGUI:Create("InlineGroup")
    PvPHotkeys:SetTitle("Hotkeys")
    pvpGUI:AddChild(PvPHotkeys)

    local interruptKey = AceGUI:Create("Keybinding")
    interruptKey:SetKey(GetBindingKey("Interrupt Toggle"))
    interruptKey:GetKey(GetBindingKey("Interrupt Toggle"))
    interruptKey:SetLabel("Interrupt Next Heal")
    interruptKey:SetCallback("OnKeyChanged", function(self, event, key)
        SetBinding(key, "Interrupt Toggle")
        SaveBindings(GetCurrentBindingSet())
    end)
    PvPHotkeys:AddChild(interruptKey)

    local burstKey = AceGUI:Create("Keybinding")
    burstKey:SetKey(GetBindingKey("Cooldown Toggle"))
    burstKey:GetKey(GetBindingKey("Cooldown Toggle"))
    burstKey:SetLabel("Burst")
    burstKey:SetCallback("OnKeyChanged", function(self, event, key)
        SetBinding(key, "Cooldown Toggle")
        SaveBindings(GetCurrentBindingSet())
    end)
    PvPHotkeys:AddChild(burstKey)

    local PvPList = AceGUI:Create("InlineGroup")
    PvPList:SetTitle("PvP Lists")
    pvpGUI:AddChild(PvPList)

    local pvpBreakableCCDt = AceGUI:Create("Dropdown")
    pvpBreakableCCDt:SetValue("Choose a Buff")
    pvpBreakableCCDt:SetList(pvpBreakableCC)
    pvpBreakableCCDt:SetFullWidth(true)
    pvpBreakableCCDt:SetText("Breakable CCs")
    --dropdown:SetLabel("Pick a Buff")
    pvpBreakableCCDt:SetCallback("OnValueChanged", function(self, event, pos)
        print(select(1, GetSpellInfo(pvpBreakableCC[pos])))
    end)
    PvPList:AddChild(pvpBreakableCCDt)

    local pvpHEALINGDt = AceGUI:Create("Dropdown")
    pvpHEALINGDt:SetValue("Choose a Buff")
    pvpHEALINGDt:SetList(pvpHEALING)
    pvpHEALINGDt:SetFullWidth(true)
    pvpHEALINGDt:SetText("Healing Spells")
    --dropdown:SetLabel("Pick a Buff")
    pvpHEALINGDt:SetCallback("OnValueChanged", function(self, event, pos)
        print(select(1, GetSpellInfo(pvpHEALING[pos])))
        --print("Spell: " .. GetSpellName(pvpHEALING[pos]))
    end)
    PvPList:AddChild(pvpHEALINGDt)

    pvpGUI:Show()
end

local randomChannel = math.random(10, 20)
local randomInterrupt = math.random(40, 70)
local randomReflect = math.random(50, 70)
local randomTimer = GetTime()
local function randomGenerator(option)
    if GetTime() - randomTimer >= 1 then
        randomInterrupt = math.random(40, 70)
        randomChannel = math.random(10, 20)
        randomReflect = math.random(50, 70)
        randomTimer = GetTime()
    end

    if option == "Interrupt" then
        return randomInterrupt
    end
    if option == "Channel" then
        return randomChannel
    end
    if option == "Reflect" then
        return randomReflect
    end
end

local WRProt = RubimRH.Spell[73]
local WRArms = RubimRH.Spell[71]
local WRFury = RubimRH.Spell[72]
local DKUnholy = RubimRH.Spell[252]
local DKBlood = RubimRH.Spell[250]
local DKFrost = RubimRH.Spell[251]
local PLRet = RubimRH.Spell[70]
local HRSurv = RubimRH.Spell[255]
local HRBM = RubimRH.Spell[BeastMastery]
local MKWind = RubimRH.Spell[Windwalker]
local RGAss = RubimRH.Spell[Assassination]
local RGSub = RubimRH.Spell[Subtlety]
local RGOut = RubimRH.Spell[Outlaw]

local stunsSpellList = {
    WRArms.Stormbolt,
    WRFury.Stormbolt,
    WRProt.Stormbolt,
    DKBlood.Asphyxiate,
}
local interruptSpellsList = {
    WRArms.Pummel,
    WRFury.Pummel,
    WRProt.Pummel,

    DKBlood.MindFreeze,
    DKFrost.MindFreeze,
    DKUnholy.MindFreeze,

    HRSurv.Muzzle,
    HRBM.CounterShot,

    RGAss.Kick,
    RGSub.Kick,
    RGOut.Kick,
}
local slowSpellsList = {
    WRArms.Hamstring,
    WRFury.PiercingHowl,
    WRProt.PiercingHowl,

    DKBlood.HeartStrike,
    DKFrost.ChainsofIce,
    DKUnholy.ChainsofIce,

    HRSurv.WingClip,
    HRBM.ConcusiveShot,
}
local function interruptSpell(useStuns)
    local useStuns = useStuns or false

    for i, v in pairs(interruptSpellsList) do
        if v:IsReady(v:MaximumRange()) then
            return v
        end
    end

    if useStuns then
        for i, v in pairs(stunsSpellList) do
            if v:IsReady(v:MaximumRange()) then
                return v
            end
        end
    end

    return Spell(1)
end
local function slowSpell()
    for i, v in pairs(slowSpellsList) do
        if v:IsReady(v:MaximumRange()) then
            return v
        end
    end
    return Spell(1)
end
local slowSpellClass = {
    5,
    6,
    7,
    8,
    9,
    11
}
function Unit:HasMagicSlow()
    local target = self.UnitID
    if target == nil then
        return false
    end
    id = select(3, UnitClass(target))
    for i = 1, #slowSpellClass do
        if id == slowSpellClass[i] then
            return true
        end
    end
    return false
end

local function GeneralPvP()
    --Interrupts Healing
    if Target:IsInterruptibleHeal() and interruptSpell():IsReady(interruptSpell()) and Target:HealthPercentage() <= 50 then
        return interruptSpell():Cast()
    end

    --Interrupts Healing
    if Target:IsInterruptibleCC() and interruptSpell():IsReady(interruptSpell()) and Target:HealthPercentage() <= 50 then
        return interruptSpell():Cast()
    end

    --Keep Slow
    if Target:IsAPlayer() then
        if Player:HasMagicSlow() and not Target:IsImmuneMagic() then
            if not Target:IsImmune() and slowSpell():IsReady(slowSpell()) and not Target:IsSnared() then
                return slowSpell():Cast()
            end
        elseif not Player:HasMagicSlow() then
            if not Target:IsImmune() and slowSpell():IsReady(slowSpell()) and not Target:IsSnared() then
                return slowSpell():Cast()
            end
        end
    end
end

function RubimRH.getArenaTarget(arenaTarget)
    RubimRH.arena1.texture:SetColorTexture(0, 0, 0, 0)
    RubimRH.arena2.texture:SetColorTexture(0, 0, 0, 0)
    RubimRH.arena3.texture:SetColorTexture(0, 0, 0, 0)

    local arenaTarget = arenaTarget:ID()
    if UnitName(arenaTarget) == UnitName('arena1') then
        RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
    elseif UnitName(arenaTarget) == UnitName('arena2') then
        RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
    elseif UnitName(arenaTarget) == UnitName('arena3') then
        RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
    end
end

local function UnholyAPL()
    if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena1Icon(DKUnholy.DarkSimulacrum:Cast())
        return
    end

    if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena2Icon(DKUnholy.DarkSimulacrum:Cast())
        return
    end

    if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena3Icon(DKUnholy.DarkSimulacrum:Cast())
        return
    end

    if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena1Icon(DKUnholy.MindFreeze:Cast())
        return
    end

    if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena2Icon(DKUnholy.MindFreeze:Cast())
        return
    end

    if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 30 then
        RubimRH.Arena3Icon(DKUnholy.MindFreeze:Cast())
        return
    end
end
local function BeastMasteryAPL()
    if Target:Exists() and (Target:IsAPlayer() or Target:IsAPvPDummy() or select(2, IsInInstance()) == "arena" or select(2, IsInInstance()) == "battleground") then
        if RubimRH.CDsON() then
            if HRBM.BestialWrath:IsReady() then
                return HRBM.BestialWrath:Cast()
            end

            if HRBM.AMurderofCrows:IsReady() then
                return HRBM.AMurderofCrows:Cast()
            end

            if HRBM.BarbedShot:IsReady() and Pet:BuffRemains(HRBM.FrenzyBuff) <= Player:GCD() then
                return HRBM.BarbedShot:Cast()
            end

            if HRBM.KillCommand:IsReady() then
                return HRBM.KillCommand:Cast()
            end

            if HRBM.BarbedShot:IsReady() and Pet:BuffStack(HRBM.FrenzyBuff) <= 2 then
                return HRBM.BarbedShot:Cast()
            end

            if HRBM.ChimaeraShot:IsReady() then
                return HRBM.ChimaeraShot:Cast()
            end

            if HRBM.BarbedShot:IsReady() and (Pet:BuffStack(HRBM.FrenzyBuff) <= 3 or Pet:BuffRemainsP(HRBM.FrenzyBuff) <= Player:GCD()) then
                return HRBM.BarbedShot:Cast()
            end
        else
            if HRBM.BarbedShot:IsReady() and (Pet:BuffStack(HRBM.FrenzyBuff) <= 3 or Pet:BuffRemainsP(HRBM.FrenzyBuff) <= Player:GCD()) then
                return HRBM.BarbedShot:Cast()
            end

            if HRBM.KillCommand:IsReady() then
                return HRBM.KillCommand:Cast()
            end

            if HRBM.ChimaeraShot:IsReady() then
                return HRBM.ChimaeraShot:Cast()
            end
        end
        return 236329
    end
end

local function emptyAPL()
end
RubimRH.Rotation.SetPvP(250, emptyAPL)
RubimRH.Rotation.SetPvP(251, emptyAPL)
RubimRH.Rotation.SetPvP(252, emptyAPL)

RubimRH.Rotation.SetPvP(577, emptyAPL)
RubimRH.Rotation.SetPvP(581, emptyAPL)

RubimRH.Rotation.SetPvP(102, emptyAPL)
RubimRH.Rotation.SetPvP(103, emptyAPL)
RubimRH.Rotation.SetPvP(104, emptyAPL)
RubimRH.Rotation.SetPvP(105, emptyAPL)

RubimRH.Rotation.SetPvP(253, emptyAPL)
RubimRH.Rotation.SetPvP(254, emptyAPL)
RubimRH.Rotation.SetPvP(255, emptyAPL)

RubimRH.Rotation.SetPvP(62, emptyAPL)
RubimRH.Rotation.SetPvP(63, emptyAPL)
RubimRH.Rotation.SetPvP(64, emptyAPL)

RubimRH.Rotation.SetPvP(268, emptyAPL)
RubimRH.Rotation.SetPvP(270, emptyAPL)
RubimRH.Rotation.SetPvP(269, emptyAPL)

RubimRH.Rotation.SetPvP(65, emptyAPL)
RubimRH.Rotation.SetPvP(66, emptyAPL)
RubimRH.Rotation.SetPvP(70, emptyAPL)

RubimRH.Rotation.SetPvP(256, emptyAPL)
RubimRH.Rotation.SetPvP(257, emptyAPL)
RubimRH.Rotation.SetPvP(258, emptyAPL)

RubimRH.Rotation.SetPvP(259, emptyAPL)
RubimRH.Rotation.SetPvP(260, emptyAPL)
RubimRH.Rotation.SetPvP(261, emptyAPL)

RubimRH.Rotation.SetPvP(262, emptyAPL)
RubimRH.Rotation.SetPvP(263, emptyAPL)
RubimRH.Rotation.SetPvP(264, emptyAPL)

RubimRH.Rotation.SetPvP(265, emptyAPL)
RubimRH.Rotation.SetPvP(266, emptyAPL)
RubimRH.Rotation.SetPvP(267, emptyAPL)

RubimRH.Rotation.SetPvP(72, emptyAPL)
RubimRH.Rotation.SetPvP(73, emptyAPL)

local function PvPRotation(specID)
    if specID == BeastMastery then
        if Target:Exists() and (Target:IsAPlayer() or Target:IsAPvPDummy() or select(2, IsInInstance()) == "arena" or select(2, IsInInstance()) == "battleground") then
            if RubimRH.CDsON() then
                if HRBM.BestialWrath:IsReady() then
                    return HRBM.BestialWrath:Cast()
                end

                if HRBM.AMurderofCrows:IsReady() then
                    return HRBM.AMurderofCrows:Cast()
                end

                if HRBM.BarbedShot:IsReady() and Pet:BuffRemains(HRBM.FrenzyBuff) <= Player:GCD() then
                    return HRBM.BarbedShot:Cast()
                end

                if HRBM.KillCommand:IsReady() then
                    return HRBM.KillCommand:Cast()
                end

                if HRBM.BarbedShot:IsReady() and Pet:BuffStack(HRBM.FrenzyBuff) <= 2 then
                    return HRBM.BarbedShot:Cast()
                end

                if HRBM.ChimaeraShot:IsReady() then
                    return HRBM.ChimaeraShot:Cast()
                end

                if HRBM.BarbedShot:IsReady() and (Pet:BuffStack(HRBM.FrenzyBuff) <= 3 or Pet:BuffRemainsP(HRBM.FrenzyBuff) <= Player:GCD()) then
                    return HRBM.BarbedShot:Cast()
                end
            else
                if HRBM.BarbedShot:IsReady() and (Pet:BuffStack(HRBM.FrenzyBuff) <= 3 or Pet:BuffRemainsP(HRBM.FrenzyBuff) <= Player:GCD()) then
                    return HRBM.BarbedShot:Cast()
                end

                if HRBM.KillCommand:IsReady() then
                    return HRBM.KillCommand:Cast()
                end

                if HRBM.ChimaeraShot:IsReady() then
                    return HRBM.ChimaeraShot:Cast()
                end
            end
            return 236329
        end

    end
    if specID == Survival then
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingHealing() and Arena.arena1:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingHealing() and Arena.arena2:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingHealing() and Arena.arena3:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if HRSurv.HydrasBite:IsAvailable() then
            CleaveSpell[HRSurv.SerpentSting:ID()] = true
        else
            CleaveSpell[HRSurv.SerpentSting:ID()] = false
        end

        if HRSurv.ShrapnelBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(270335)
        elseif HRSurv.VolatileBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(271045)
        elseif HRSurv.PheromoneBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(270323)
        else
            HRSurv.WildfireBomb = Spell(259495)
        end
        HRSurv.ShrapnelBomb.TextureSpellID = { 269747 }
        HRSurv.PheromoneBomb.TextureSpellID = { 269747 }
        HRSurv.VolatileBomb.TextureSpellID = { 269747 }
        HRSurv.WildfireBomb.TextureSpellID = { 269747 }
    end
    if specID == Arms then
        if select(2, IsInInstance()) == "arena" then

            if not Arena.arena1:IsImmune() and Arena.arena1:CastingHealing() and Arena.arena1:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena2:IsImmune() and Arena.arena2:CastingHealing() and Arena.arena2:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena3:IsImmune() and Arena.arena3:CastingHealing() and Arena.arena3:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsInterruptible() and WRArms.Pummel:IsCastable() then
                RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
            end

            if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Arena.arena1:CastPercentage() >= randomGenerator("Reflect") then
                return WRArms.SpellReflection:Cast()
            end

            if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Arena.arena2:CastPercentage() >= randomGenerator("Reflect") then
                return WRArms.SpellReflection:Cast()
            end

            if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Arena.arena3:CastPercentage() >= randomGenerator("Reflect") then
                return WRArms.SpellReflection:Cast()
            end

            if not Arena.arena1:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena1Icon(WRArms.Rend:Cast())
                return
            end

            if not Arena.arena2:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena2Icon(WRArms.Rend:Cast())
                return
            end

            if not Arena.arena3:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena3Icon(WRArms.Rend:Cast())
                return
            end

            if not Arena.arena1:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena1:IsBursting() and Arena.arena1:IsDisarmable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena1Icon(WRArms.Disarm:Cast())
                return
            end

            if not Arena.arena2:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena2:IsBursting() and Arena.arena2:IsDisarmable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena2Icon(WRArms.Disarm:Cast())
                return
            end

            if not Arena.arena3:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena3:IsBursting() and Arena.arena3:IsDisarmable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
                RubimRH.Arena3Icon(WRArms.Disarm:Cast())
                return
            end
        end

        if Target:Exists() then
            if WRArms.Execute:IsReadyMorph() and Target:MinDistanceToPlayer(true) >= 8 and Target:MinDistanceToPlayer(true) <= 15 and WRArms.DeathSentence:IsAvailable() then
                return WRArms.Execute:Cast()
            end

            if not Target:IsImmune() and Target:CastingCC() and Target:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
                return WRArms.SpellReflection:Cast()
            end

            if not Target:IsImmune() and Target:IsBursting() and Target:IsDisarmable() and WRArms.Disarm:IsReady("Melee") then
                return WRArms.Disarm:Cast()
            end

            if not Target:IsImmune() and Target:HealthPercentage() <= 50 and WRArms.SharpenBlade:IsReady("Melee") and Target:IsAPlayer() then
                return WRArms.SharpenBlade:Cast()
            end
        end
    end
    if specID == Unholy then
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena1Icon(DKUnholy.DarkSimulacrum:Cast())
            return
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena2Icon(DKUnholy.DarkSimulacrum:Cast())
            return
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and DKUnholy.DarkSimulacrum:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena3Icon(DKUnholy.DarkSimulacrum:Cast())
            return
        end

        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena1Icon(DKUnholy.MindFreeze:Cast())
            return
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena2Icon(DKUnholy.MindFreeze:Cast())
            return
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and DKUnholy.MindFreeze:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 30 then
            RubimRH.Arena3Icon(DKUnholy.MindFreeze:Cast())
            return
        end

    end

end
local function AllPvP()
    local ArmsArenaSpell, ArmsArenaInterrupt
    local ArmsArenaPvP, ArmsPvP, FuryPvP
    local SurvRotation, SurvArena
    local UnholyArenaInterrupt, UnholyPvP

    SurvRotation = function()
        if HRSurv.HydrasBite:IsAvailable() then
            CleaveSpell[HRSurv.SerpentSting:ID()] = true
        else
            CleaveSpell[HRSurv.SerpentSting:ID()] = false
        end

        if HRSurv.ShrapnelBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(270335)
        elseif HRSurv.VolatileBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(271045)
        elseif HRSurv.PheromoneBomb:IsReadyMorph() then
            HRSurv.WildfireBomb = Spell(270323)
        else
            HRSurv.WildfireBomb = Spell(259495)
        end
        HRSurv.ShrapnelBomb.TextureSpellID = { 269747 }
        HRSurv.PheromoneBomb.TextureSpellID = { 269747 }
        HRSurv.VolatileBomb.TextureSpellID = { 269747 }
        HRSurv.WildfireBomb.TextureSpellID = { 269747 }

        if RubimRH.CDsON() then
            --1. Serpent Sting (If serpent sting debuff is not on the target or has <3s left)
            if HRSurv.SerpentSting:IsReady() and (Target:DebuffRefreshableCP(HRSurv.SerpentStingDebuff)) then
                return HRSurv.SerpentSting:Cast()
            end

            --2. A Murder of Crows (131894)
            if HRSurv.AMurderofCrows:IsReady() and (true) then
                return HRSurv.AMurderofCrows:Cast()
            end

            --3. Co-ordinatewd assault (266779)
            if HRSurv.CoordinatedAssault:IsReady() and (true) then
                return HRSurv.CoordinatedAssault:Cast()
            end

            --4. 2x Wildfire Bomb charges !!CC CHECK!!! SMALL FRONTAL CONE
            if HRSurv.WildfireBomb:IsReadyMorph() then
                return HRSurv.WildfireBomb:Cast()
            end

            --5. Mongoose Bite (IF 5 STACKS and above 60 focus)
            if HRSurv.MongooseBite:IsReady() and (Player:BuffP(HRSurv.MongooseFuryBuff) or Player:Focus() > 60) then
                return HRSurv.MongooseBite:Cast()
            end

            --6. Kill Command if <85 focus
            if HRSurv.KillCommand:IsReady() and (Player:Focus() < 85) then
                return HRSurv.KillCommand:Cast()
            end

            --7. Mongoose bite
            if HRSurv.MongooseBite:IsReady() then
                return HRSurv.MongooseBite:Cast()
            end

            --8. Viper's Venom Proc
            if HRSurv.SerpentSting:IsReady() and (Player:BuffP(HRSurv.VipersVenomBuff)) then
                return HRSurv.SerpentSting:Cast()
            end
        else
            --1. Kill Command(259489) if we are <85 focus
            if HRSurv.KillCommand:IsReady() and Player:Focus() < 85 then
                debug("1. Kill Command(259489) if we are <85 focus")
                return HRSurv.KillCommand:Cast()
            end

            --2. ---->Latent Poison Azerite trait: Mongoose Bite if 10 Stacks of Latent Poison(debuff ID 273286)
            if HRSurv.LatentPoison:AzeriteEnabled() and Target:DebuffStack(HRSurv.LatentPoisonDebuff) >= 10 and HRSurv.MongooseBiteEagle:IsReadyMorph() then
                debug("2. ---->Latent Poison Azerite trait: Mongoose Bite if 10 Stacks of Latent Poison(debuff ID 273286)")
                return HRSurv.MongooseBiteEagle:Cast()
            end

            if HRSurv.LatentPoison:AzeriteEnabled() and Target:DebuffStack(HRSurv.LatentPoisonDebuff) >= 10 and HRSurv.MongooseBiteEagle:IsReadyMorph() then
                debug("2. ---->Latent Poison Azerite trait: Mongoose Bite if 10 Stacks of Latent Poison(debuff ID 273286)")
                return HRSurv.MongooseBiteEagle:Cast()
            end
            --if HRSurv.KillCommand:IsReady() and Player:Focus() < 85 then
            --debug("Kill Command(259489) if we are <85 focus")
            --  return HRSurv.KillCommand:Cast()
            --end

            --3. Mongoose Bite(259387) (IF WE HAVE 4> STACKS OF MONGOOSE FURY(259388)
            if HRSurv.MongooseBiteEagle:IsReadyMorph() and Player:Buff(HRSurv.AspectoftheEagle) and Player:BuffStack(HRSurv.MongooseFuryBuff) > 4 then
                debug("3. Mongoose Bite(259387) (IF WE HAVE 4> STACKS OF MONGOOSE FURY(259388)")
                return HRSurv.MongooseBiteEagle:Cast()
            end
            -- mongoose_bite
            if HRSurv.MongooseBite:IsReady() and Player:BuffStack(HRSurv.MongooseFuryBuff) > 4 then
                debug("3. Mongoose Bite(259387) (IF WE HAVE 4> STACKS OF MONGOOSE FURY(259388)")
                return HRSurv.MongooseBite:Cast()
            end

            --4. Serpent Sting(259491) (if serpent sting debuff is not on the target OR has <3s left.)
            if HRSurv.SerpentSting:IsReady() and Target:DebuffRefreshableCP(HRSurv.SerpentStingDebuff) then
                debug("4. Serpent Sting(259491) (if serpent sting debuff is not on the target OR has <3s left.)")
                return HRSurv.SerpentSting:Cast()
            end

            --5. Wildfire Infusion x1 !!CC CHECK!!! SMALL FRONTAL CONE (Use if we have 2 charges OR <2s left until we get our second charge again).)
            if HRSurv.WildfireBomb:IsReadyMorph() and HRSurv.WildfireBomb:ChargesFractional() >= 1.8 and (HRSurv.FreezingTrap:CooldownRemains() > 14) then
                debug("5. Wildfire Infusion x1 !!CC CHECK!!! SMALL FRONTAL CONE (Use if we have 2 charges OR <2s left until we get our second charge again).")
                return HRSurv.WildfireBomb:Cast()
            end

            --^^When our freezing trap is off CD or <14s then HOLD Wildfire Bomb usage.^^
            --^^^^^^^^^^^^^^^^^^^ See usage Conditions Below ^^^^^^^^^^^^^^^^^^
            --6. Viper's Venom procs(268552) use Serpent Sting ASAP UNLESS we have Mongoose Fury up.
            if HRSurv.SerpentSting:IsReady() and (Player:BuffP(HRSurv.VipersVenomBuff)) then
                debug("6. Viper's Venom procs(268552) use Serpent Sting ASAP UNLESS we have Mongoose Fury up.")
                return HRSurv.SerpentSting:Cast()
            end

            --7. Mongoose Bite
            if HRSurv.MongooseBiteEagle:IsReadyMorph() and Player:Buff(HRSurv.AspectoftheEagle) then
                debug("7. Mongoose Bite")
                return HRSurv.MongooseBiteEagle:Cast()
            end
            -- mongoose_bite
            if HRSurv.MongooseBite:IsReady() then
                debug("7. Mongoose Bite")
                return HRSurv.MongooseBite:Cast()
            end

            -- raptor_strike_eagle
            if HRSurv.RaptorStrikeEagle:IsReadyMorph() and Player:Buff(HRSurv.AspectoftheEagle) then
                debug("7. Mongoose Bite")
                return HRSurv.RaptorStrike:Cast()
            end
            -- raptor_strike
            if HRSurv.RaptorStrike:IsReady() and (true) then
                debug("7. Mongoose Bite")
                return HRSurv.RaptorStrike:Cast()
            end
        end
        debug("999. Nothing to do")
        return 236329
    end
    SurvArena = function()
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingHealing() and Arena.arena1:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Target:HealthPercentage() <= 40 and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingHealing() and Arena.arena2:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Target:HealthPercentage() <= 40 and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingHealing() and Arena.arena3:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Target:HealthPercentage() <= 40 and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end

        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsInterruptible() and HRSurv.Muzzle:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
            return
        end
    end

    UnholyPvP = function()
        --if DKUnholy.NecroticStrike:IsReady() and Target:HealthPercentage() <= 50 and Target:Debuff(DKUnholy.VirulentPlagueDebuff) then
        --  return DKUnholy.NecroticStrike:Cast()
        --end

    end
    UnholyArenaInterrupt = function()
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingHealing() and Arena.arena1:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingHealing() and Arena.arena2:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingHealing() and Arena.arena3:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsInterruptible() and DKUnholy.MindFreeze:IsCastable() then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end
    end

    FuryPvP = function()
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsTargeting(Player) and WRFury.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRFury.SpellReflection:Cast()
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsTargeting(Player) and WRFury.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRFury.SpellReflection:Cast()
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsTargeting(Player) and WRFury.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRFury.SpellReflection:Cast()
        end

        if not Target:IsImmune() and Target:CastingCC() and Target:IsTargeting(Player) and WRFury.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRFury.SpellReflection:Cast()
        end
    end
    ArmsPvP = function()
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRArms.SpellReflection:Cast()
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRArms.SpellReflection:Cast()
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRArms.SpellReflection:Cast()
        end

        if not Target:IsImmune() and Target:CastingCC() and Target:IsTargeting(Player) and WRArms.SpellReflection:IsCastable() and Target:CastPercentage() >= randomGenerator("Reflect") then
            return WRArms.SpellReflection:Cast()
        end

        if not Target:IsImmune() and Target:IsBursting() and Target:IsDisarmable() and WRArms.Disarm:IsReady("Melee") then
            return WRArms.Disarm:Cast()
        end

        if not Target:IsImmune() and Target:HealthPercentage() <= 50 and WRArms.SharpenBlade:IsReady("Melee") then
            return WRArms.SharpenBlade:Cast()
        end
    end

    ArmsArenaInterrupt = function()
        RubimRH.arena2.texture:SetColorTexture(0, 0, 0, 0)
        if not Arena.arena1:IsImmune() and Arena.arena1:CastingHealing() and Arena.arena1:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingHealing() and Arena.arena2:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingHealing() and Arena.arena3:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena1:IsImmune() and Arena.arena1:CastingCC() and Arena.arena1:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena1.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena2:IsImmune() and Arena.arena2:CastingCC() and Arena.arena2:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena2.texture:SetColorTexture(0, 0.56, 0, 1)
        end

        if not Arena.arena3:IsImmune() and Arena.arena3:CastingCC() and Arena.arena3:IsInterruptible() and WRArms.Pummel:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.arena3.texture:SetColorTexture(0, 0.56, 0, 1)
        end
    end
    ArmsArenaSpell = function()
        RubimRH.Arena1Icon(nil)
        RubimRH.Arena1Icon(nil)
        RubimRH.Arena3Icon(nil)
        if not Arena.arena1:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena1Icon(WRArms.Rend:Cast())
            return
        end

        if not Arena.arena2:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena2:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena2Icon(WRArms.Rend:Cast())
            return
        end

        if not Arena.arena3:IsImmune() and WRArms.Rend:IsCastable() and Arena.arena3:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena3Icon(WRArms.Rend:Cast())
            return
        end

        if not Arena.arena1:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena1:IsBursting() and Arena.arena1:IsDisarmable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena1Icon(WRArms.Disarm:Cast())
            return
        end

        if not Arena.arena1:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena2:IsBursting() and Arena.arena2:IsDisarmable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena1Icon(WRArms.Disarm:Cast())
            return
        end

        if not Arena.arena1:IsImmune() and WRArms.Disarm:IsCastable() and Arena.arena2:IsBursting() and Arena.arena2:IsDisarmable() and Arena.arena1:MinDistanceToPlayer(true) <= 5 then
            RubimRH.Arena1Icon(WRArms.Disarm:Cast())
            return
        end
    end

    local instanceType = select(2, IsInInstance())
    if instanceType == "arena" then
        UnholyArenaInterrupt()
        ArmsArenaInterrupt()
        ArmsArenaSpell()
    end

    if RubimRH.playerSpec == Arms and ArmsPvP() ~= nil then
        return ArmsPvP()
    end
    if RubimRH.playerSpec == Fury and FuryPvP() ~= nil then
        return FuryPvP()
    end

    if Target:IsAPlayer() or Target:IsAPvPDummy() then
        --if RubimRH.playerSpec == Survival then
        --  return SurvRotation()
        --end
    end
end
function Spell:CanBreakCC()
    local willBreak = CleaveSpell[self:ID()] or false

    if willBreak == false then
        return false
    end

    if not RubimRH.db.profile.mainOption.smartCleave or not Player:AreaCC(12) then
        return false
    end
    -- and Player:AreaCC(12)
    if RubimRH.db.profile.mainOption.smartCleave and Player:AreaCC(12) then
        if CleaveSpell[self:ID()] == true then
            return true
        end
    end
end
function RubimRH.PvP()
    RubimRH.Arena1Icon(nil)
    RubimRH.Arena2Icon(nil)
    RubimRH.Arena3Icon(nil)
    RubimRH.arena1.texture:SetColorTexture(0, 0, 0, 0)
    RubimRH.arena2.texture:SetColorTexture(0, 0, 0, 0)
    RubimRH.arena3.texture:SetColorTexture(0, 0, 0, 0)

    if Target:IsImmune() then
        return 0, 236390
    end

    if Target:IsImmunePhys() then
        return 0, 236390
    end

    if Target:IsCC() then
        return 0, 236390
    end

    if Player:IsDisarmed() then
        return 0, 236390
    end

    if GeneralPvP() ~= nil then
        return GeneralPvP()
    end

    if RubimRH.Rotation.PvP[RubimRH.playerSpec]() ~= nil then
        return RubimRH.Rotation.PvP[RubimRH.playerSpec]()
    end
end